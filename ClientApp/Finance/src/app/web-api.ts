/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.7.0 (NJsonSchema v10.6.7.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

export class Client {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080";
  }

  /**
   * financeRecordUser
   * @param id id
   * @return OK
   */
  financeRecordUserUsingGET(id: number): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/financeRecords/{id}/user";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "application/hal+json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFinanceRecordUserUsingGET(_response);
    });
  }

  protected processFinanceRecordUserUsingGET(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * financeRecordUser
   * @param id id
   * @param body (optional)
   * @return OK
   */
  financeRecordUserUsingPUT(id: number, body: string | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/financeRecords/{id}/user";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFinanceRecordUserUsingPUT(_response);
    });
  }

  protected processFinanceRecordUserUsingPUT(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * financeRecordUser
   * @param id id
   * @param body (optional)
   * @return OK
   */
  financeRecordUserUsingPOST(id: number, body: string | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/financeRecords/{id}/user";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFinanceRecordUserUsingPOST(_response);
    });
  }

  protected processFinanceRecordUserUsingPOST(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * financeRecordUser
   * @param id id
   * @return OK
   */
  financeRecordUserUsingDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + "/financeRecords/{id}/user";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFinanceRecordUserUsingDELETE(_response);
    });
  }

  protected processFinanceRecordUserUsingDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * financeRecordUser
   * @param id id
   * @param body (optional)
   * @return OK
   */
  financeRecordUserUsingPATCH(id: number, body: string | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/financeRecords/{id}/user";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFinanceRecordUserUsingPATCH(_response);
    });
  }

  protected processFinanceRecordUserUsingPATCH(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * findAllFinanceRecord
   * @param page (optional) page
   * @param size (optional) size
   * @param sort (optional) sort
   * @return OK
   */
  findAllFinanceRecordUsingGET(page: number | undefined, size: number | undefined, sort: string | undefined): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords?";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null)
      throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (sort === null)
      throw new Error("The parameter 'sort' cannot be null.");
    else if (sort !== undefined)
      url_ += "sort=" + encodeURIComponent("" + sort) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAllFinanceRecordUsingGET(_response);
    });
  }

  protected processFindAllFinanceRecordUsingGET(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * saveFinanceRecord
   * @param body (optional)
   * @return OK
   */
  saveFinanceRecordUsingPOST(body: FinanceRecord | undefined): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveFinanceRecordUsingPOST(_response);
    });
  }

  protected processSaveFinanceRecordUsingPOST(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }

  /**
   * findAllByUserFinanceRecord
   * @param accountNonExpired (optional)
   * @param accountNonLocked (optional)
   * @param authorities0_authority (optional)
   * @param createdDate (optional)
   * @param credentialsNonExpired (optional)
   * @param email (optional)
   * @param enabled (optional)
   * @param financerecord0_amount (optional)
   * @param financerecord0_createdDate (optional)
   * @param financerecord0_id (optional)
   * @param financerecord0_type (optional)
   * @param financerecord0_user_accountNonExpired (optional)
   * @param financerecord0_user_accountNonLocked (optional)
   * @param financerecord0_user_authorities0_authority (optional)
   * @param financerecord0_user_createdDate (optional)
   * @param financerecord0_user_credentialsNonExpired (optional)
   * @param financerecord0_user_email (optional)
   * @param financerecord0_user_enabled (optional)
   * @param financerecord0_user_firstname (optional)
   * @param financerecord0_user_id (optional)
   * @param financerecord0_user_lastname (optional)
   * @param financerecord0_user_middlename (optional)
   * @param financerecord0_user_password (optional)
   * @param financerecord0_user_role (optional)
   * @param financerecord0_user_username (optional)
   * @param firstname (optional)
   * @param id (optional)
   * @param lastname (optional)
   * @param middlename (optional)
   * @param password (optional)
   * @param role (optional)
   * @param username (optional)
   * @return OK
   */
  findAllByUserFinanceRecordUsingGET(accountNonExpired: boolean | undefined, accountNonLocked: boolean | undefined, authorities0_authority: string | undefined, createdDate: Date | undefined, credentialsNonExpired: boolean | undefined, email: string | undefined, enabled: boolean | undefined, financerecord0_amount: number | undefined, financerecord0_createdDate: Date | undefined, financerecord0_id: number | undefined, financerecord0_type: number | undefined, financerecord0_user_accountNonExpired: boolean | undefined, financerecord0_user_accountNonLocked: boolean | undefined, financerecord0_user_authorities0_authority: string | undefined, financerecord0_user_createdDate: Date | undefined, financerecord0_user_credentialsNonExpired: boolean | undefined, financerecord0_user_email: string | undefined, financerecord0_user_enabled: boolean | undefined, financerecord0_user_firstname: string | undefined, financerecord0_user_id: number | undefined, financerecord0_user_lastname: string | undefined, financerecord0_user_middlename: string | undefined, financerecord0_user_password: string | undefined, financerecord0_user_role: FinancerecordOf_0Role | undefined, financerecord0_user_username: string | undefined, firstname: string | undefined, id: number | undefined, lastname: string | undefined, middlename: string | undefined, password: string | undefined, role: Role | undefined, username: string | undefined): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords/search/findAllByUser?";
    if (accountNonExpired === null)
      throw new Error("The parameter 'accountNonExpired' cannot be null.");
    else if (accountNonExpired !== undefined)
      url_ += "accountNonExpired=" + encodeURIComponent("" + accountNonExpired) + "&";
    if (accountNonLocked === null)
      throw new Error("The parameter 'accountNonLocked' cannot be null.");
    else if (accountNonLocked !== undefined)
      url_ += "accountNonLocked=" + encodeURIComponent("" + accountNonLocked) + "&";
    if (authorities0_authority === null)
      throw new Error("The parameter 'authorities0_authority' cannot be null.");
    else if (authorities0_authority !== undefined)
      url_ += "authorities[0].authority=" + encodeURIComponent("" + authorities0_authority) + "&";
    if (createdDate === null)
      throw new Error("The parameter 'createdDate' cannot be null.");
    else if (createdDate !== undefined)
      url_ += "createdDate=" + encodeURIComponent(createdDate ? "" + createdDate.toJSON() : "") + "&";
    if (credentialsNonExpired === null)
      throw new Error("The parameter 'credentialsNonExpired' cannot be null.");
    else if (credentialsNonExpired !== undefined)
      url_ += "credentialsNonExpired=" + encodeURIComponent("" + credentialsNonExpired) + "&";
    if (email === null)
      throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    if (enabled === null)
      throw new Error("The parameter 'enabled' cannot be null.");
    else if (enabled !== undefined)
      url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
    if (financerecord0_amount === null)
      throw new Error("The parameter 'financerecord0_amount' cannot be null.");
    else if (financerecord0_amount !== undefined)
      url_ += "financerecord[0].amount=" + encodeURIComponent("" + financerecord0_amount) + "&";
    if (financerecord0_createdDate === null)
      throw new Error("The parameter 'financerecord0_createdDate' cannot be null.");
    else if (financerecord0_createdDate !== undefined)
      url_ += "financerecord[0].createdDate=" + encodeURIComponent(financerecord0_createdDate ? "" + financerecord0_createdDate.toJSON() : "") + "&";
    if (financerecord0_id === null)
      throw new Error("The parameter 'financerecord0_id' cannot be null.");
    else if (financerecord0_id !== undefined)
      url_ += "financerecord[0].id=" + encodeURIComponent("" + financerecord0_id) + "&";
    if (financerecord0_type === null)
      throw new Error("The parameter 'financerecord0_type' cannot be null.");
    else if (financerecord0_type !== undefined)
      url_ += "financerecord[0].type=" + encodeURIComponent("" + financerecord0_type) + "&";
    if (financerecord0_user_accountNonExpired === null)
      throw new Error("The parameter 'financerecord0_user_accountNonExpired' cannot be null.");
    else if (financerecord0_user_accountNonExpired !== undefined)
      url_ += "financerecord[0].user.accountNonExpired=" + encodeURIComponent("" + financerecord0_user_accountNonExpired) + "&";
    if (financerecord0_user_accountNonLocked === null)
      throw new Error("The parameter 'financerecord0_user_accountNonLocked' cannot be null.");
    else if (financerecord0_user_accountNonLocked !== undefined)
      url_ += "financerecord[0].user.accountNonLocked=" + encodeURIComponent("" + financerecord0_user_accountNonLocked) + "&";
    if (financerecord0_user_authorities0_authority === null)
      throw new Error("The parameter 'financerecord0_user_authorities0_authority' cannot be null.");
    else if (financerecord0_user_authorities0_authority !== undefined)
      url_ += "financerecord[0].user.authorities[0].authority=" + encodeURIComponent("" + financerecord0_user_authorities0_authority) + "&";
    if (financerecord0_user_createdDate === null)
      throw new Error("The parameter 'financerecord0_user_createdDate' cannot be null.");
    else if (financerecord0_user_createdDate !== undefined)
      url_ += "financerecord[0].user.createdDate=" + encodeURIComponent(financerecord0_user_createdDate ? "" + financerecord0_user_createdDate.toJSON() : "") + "&";
    if (financerecord0_user_credentialsNonExpired === null)
      throw new Error("The parameter 'financerecord0_user_credentialsNonExpired' cannot be null.");
    else if (financerecord0_user_credentialsNonExpired !== undefined)
      url_ += "financerecord[0].user.credentialsNonExpired=" + encodeURIComponent("" + financerecord0_user_credentialsNonExpired) + "&";
    if (financerecord0_user_email === null)
      throw new Error("The parameter 'financerecord0_user_email' cannot be null.");
    else if (financerecord0_user_email !== undefined)
      url_ += "financerecord[0].user.email=" + encodeURIComponent("" + financerecord0_user_email) + "&";
    if (financerecord0_user_enabled === null)
      throw new Error("The parameter 'financerecord0_user_enabled' cannot be null.");
    else if (financerecord0_user_enabled !== undefined)
      url_ += "financerecord[0].user.enabled=" + encodeURIComponent("" + financerecord0_user_enabled) + "&";
    if (financerecord0_user_firstname === null)
      throw new Error("The parameter 'financerecord0_user_firstname' cannot be null.");
    else if (financerecord0_user_firstname !== undefined)
      url_ += "financerecord[0].user.firstname=" + encodeURIComponent("" + financerecord0_user_firstname) + "&";
    if (financerecord0_user_id === null)
      throw new Error("The parameter 'financerecord0_user_id' cannot be null.");
    else if (financerecord0_user_id !== undefined)
      url_ += "financerecord[0].user.id=" + encodeURIComponent("" + financerecord0_user_id) + "&";
    if (financerecord0_user_lastname === null)
      throw new Error("The parameter 'financerecord0_user_lastname' cannot be null.");
    else if (financerecord0_user_lastname !== undefined)
      url_ += "financerecord[0].user.lastname=" + encodeURIComponent("" + financerecord0_user_lastname) + "&";
    if (financerecord0_user_middlename === null)
      throw new Error("The parameter 'financerecord0_user_middlename' cannot be null.");
    else if (financerecord0_user_middlename !== undefined)
      url_ += "financerecord[0].user.middlename=" + encodeURIComponent("" + financerecord0_user_middlename) + "&";
    if (financerecord0_user_password === null)
      throw new Error("The parameter 'financerecord0_user_password' cannot be null.");
    else if (financerecord0_user_password !== undefined)
      url_ += "financerecord[0].user.password=" + encodeURIComponent("" + financerecord0_user_password) + "&";
    if (financerecord0_user_role === null)
      throw new Error("The parameter 'financerecord0_user_role' cannot be null.");
    else if (financerecord0_user_role !== undefined)
      financerecord0_user_role && financerecord0_user_role.forEach(item => { url_ += "financerecord[0].user.role=" + encodeURIComponent("" + item) + "&"; });
    if (financerecord0_user_username === null)
      throw new Error("The parameter 'financerecord0_user_username' cannot be null.");
    else if (financerecord0_user_username !== undefined)
      url_ += "financerecord[0].user.username=" + encodeURIComponent("" + financerecord0_user_username) + "&";
    if (firstname === null)
      throw new Error("The parameter 'firstname' cannot be null.");
    else if (firstname !== undefined)
      url_ += "firstname=" + encodeURIComponent("" + firstname) + "&";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (lastname === null)
      throw new Error("The parameter 'lastname' cannot be null.");
    else if (lastname !== undefined)
      url_ += "lastname=" + encodeURIComponent("" + lastname) + "&";
    if (middlename === null)
      throw new Error("The parameter 'middlename' cannot be null.");
    else if (middlename !== undefined)
      url_ += "middlename=" + encodeURIComponent("" + middlename) + "&";
    if (password === null)
      throw new Error("The parameter 'password' cannot be null.");
    else if (password !== undefined)
      url_ += "password=" + encodeURIComponent("" + password) + "&";
    if (role === null)
      throw new Error("The parameter 'role' cannot be null.");
    else if (role !== undefined)
      role && role.forEach(item => { url_ += "role=" + encodeURIComponent("" + item) + "&"; });
    if (username === null)
      throw new Error("The parameter 'username' cannot be null.");
    else if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAllByUserFinanceRecordUsingGET(_response);
    });
  }

  protected processFindAllByUserFinanceRecordUsingGET(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * findFinanceRecordByIdAndUserFinanceRecord
   * @param accountNonExpired (optional)
   * @param accountNonLocked (optional)
   * @param authorities0_authority (optional)
   * @param createdDate (optional)
   * @param credentialsNonExpired (optional)
   * @param email (optional)
   * @param enabled (optional)
   * @param financerecord0_amount (optional)
   * @param financerecord0_createdDate (optional)
   * @param financerecord0_id (optional)
   * @param financerecord0_type (optional)
   * @param financerecord0_user_accountNonExpired (optional)
   * @param financerecord0_user_accountNonLocked (optional)
   * @param financerecord0_user_authorities0_authority (optional)
   * @param financerecord0_user_createdDate (optional)
   * @param financerecord0_user_credentialsNonExpired (optional)
   * @param financerecord0_user_email (optional)
   * @param financerecord0_user_enabled (optional)
   * @param financerecord0_user_firstname (optional)
   * @param financerecord0_user_id (optional)
   * @param financerecord0_user_lastname (optional)
   * @param financerecord0_user_middlename (optional)
   * @param financerecord0_user_password (optional)
   * @param financerecord0_user_role (optional)
   * @param financerecord0_user_username (optional)
   * @param firstname (optional)
   * @param id (optional) id
   * @param lastname (optional)
   * @param middlename (optional)
   * @param password (optional)
   * @param role (optional)
   * @param username (optional)
   * @return OK
   */
  findFinanceRecordByIdAndUserFinanceRecordUsingGET(accountNonExpired: boolean | undefined, accountNonLocked: boolean | undefined, authorities0_authority: string | undefined, createdDate: Date | undefined, credentialsNonExpired: boolean | undefined, email: string | undefined, enabled: boolean | undefined, financerecord0_amount: number | undefined, financerecord0_createdDate: Date | undefined, financerecord0_id: number | undefined, financerecord0_type: number | undefined, financerecord0_user_accountNonExpired: boolean | undefined, financerecord0_user_accountNonLocked: boolean | undefined, financerecord0_user_authorities0_authority: string | undefined, financerecord0_user_createdDate: Date | undefined, financerecord0_user_credentialsNonExpired: boolean | undefined, financerecord0_user_email: string | undefined, financerecord0_user_enabled: boolean | undefined, financerecord0_user_firstname: string | undefined, financerecord0_user_id: number | undefined, financerecord0_user_lastname: string | undefined, financerecord0_user_middlename: string | undefined, financerecord0_user_password: string | undefined, financerecord0_user_role: FinancerecordOf_0Role2 | undefined, financerecord0_user_username: string | undefined, firstname: string | undefined, id: number | undefined, lastname: string | undefined, middlename: string | undefined, password: string | undefined, role: Role2 | undefined, username: string | undefined): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords/search/findFinanceRecordByIdAndUser?";
    if (accountNonExpired === null)
      throw new Error("The parameter 'accountNonExpired' cannot be null.");
    else if (accountNonExpired !== undefined)
      url_ += "accountNonExpired=" + encodeURIComponent("" + accountNonExpired) + "&";
    if (accountNonLocked === null)
      throw new Error("The parameter 'accountNonLocked' cannot be null.");
    else if (accountNonLocked !== undefined)
      url_ += "accountNonLocked=" + encodeURIComponent("" + accountNonLocked) + "&";
    if (authorities0_authority === null)
      throw new Error("The parameter 'authorities0_authority' cannot be null.");
    else if (authorities0_authority !== undefined)
      url_ += "authorities[0].authority=" + encodeURIComponent("" + authorities0_authority) + "&";
    if (createdDate === null)
      throw new Error("The parameter 'createdDate' cannot be null.");
    else if (createdDate !== undefined)
      url_ += "createdDate=" + encodeURIComponent(createdDate ? "" + createdDate.toJSON() : "") + "&";
    if (credentialsNonExpired === null)
      throw new Error("The parameter 'credentialsNonExpired' cannot be null.");
    else if (credentialsNonExpired !== undefined)
      url_ += "credentialsNonExpired=" + encodeURIComponent("" + credentialsNonExpired) + "&";
    if (email === null)
      throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    if (enabled === null)
      throw new Error("The parameter 'enabled' cannot be null.");
    else if (enabled !== undefined)
      url_ += "enabled=" + encodeURIComponent("" + enabled) + "&";
    if (financerecord0_amount === null)
      throw new Error("The parameter 'financerecord0_amount' cannot be null.");
    else if (financerecord0_amount !== undefined)
      url_ += "financerecord[0].amount=" + encodeURIComponent("" + financerecord0_amount) + "&";
    if (financerecord0_createdDate === null)
      throw new Error("The parameter 'financerecord0_createdDate' cannot be null.");
    else if (financerecord0_createdDate !== undefined)
      url_ += "financerecord[0].createdDate=" + encodeURIComponent(financerecord0_createdDate ? "" + financerecord0_createdDate.toJSON() : "") + "&";
    if (financerecord0_id === null)
      throw new Error("The parameter 'financerecord0_id' cannot be null.");
    else if (financerecord0_id !== undefined)
      url_ += "financerecord[0].id=" + encodeURIComponent("" + financerecord0_id) + "&";
    if (financerecord0_type === null)
      throw new Error("The parameter 'financerecord0_type' cannot be null.");
    else if (financerecord0_type !== undefined)
      url_ += "financerecord[0].type=" + encodeURIComponent("" + financerecord0_type) + "&";
    if (financerecord0_user_accountNonExpired === null)
      throw new Error("The parameter 'financerecord0_user_accountNonExpired' cannot be null.");
    else if (financerecord0_user_accountNonExpired !== undefined)
      url_ += "financerecord[0].user.accountNonExpired=" + encodeURIComponent("" + financerecord0_user_accountNonExpired) + "&";
    if (financerecord0_user_accountNonLocked === null)
      throw new Error("The parameter 'financerecord0_user_accountNonLocked' cannot be null.");
    else if (financerecord0_user_accountNonLocked !== undefined)
      url_ += "financerecord[0].user.accountNonLocked=" + encodeURIComponent("" + financerecord0_user_accountNonLocked) + "&";
    if (financerecord0_user_authorities0_authority === null)
      throw new Error("The parameter 'financerecord0_user_authorities0_authority' cannot be null.");
    else if (financerecord0_user_authorities0_authority !== undefined)
      url_ += "financerecord[0].user.authorities[0].authority=" + encodeURIComponent("" + financerecord0_user_authorities0_authority) + "&";
    if (financerecord0_user_createdDate === null)
      throw new Error("The parameter 'financerecord0_user_createdDate' cannot be null.");
    else if (financerecord0_user_createdDate !== undefined)
      url_ += "financerecord[0].user.createdDate=" + encodeURIComponent(financerecord0_user_createdDate ? "" + financerecord0_user_createdDate.toJSON() : "") + "&";
    if (financerecord0_user_credentialsNonExpired === null)
      throw new Error("The parameter 'financerecord0_user_credentialsNonExpired' cannot be null.");
    else if (financerecord0_user_credentialsNonExpired !== undefined)
      url_ += "financerecord[0].user.credentialsNonExpired=" + encodeURIComponent("" + financerecord0_user_credentialsNonExpired) + "&";
    if (financerecord0_user_email === null)
      throw new Error("The parameter 'financerecord0_user_email' cannot be null.");
    else if (financerecord0_user_email !== undefined)
      url_ += "financerecord[0].user.email=" + encodeURIComponent("" + financerecord0_user_email) + "&";
    if (financerecord0_user_enabled === null)
      throw new Error("The parameter 'financerecord0_user_enabled' cannot be null.");
    else if (financerecord0_user_enabled !== undefined)
      url_ += "financerecord[0].user.enabled=" + encodeURIComponent("" + financerecord0_user_enabled) + "&";
    if (financerecord0_user_firstname === null)
      throw new Error("The parameter 'financerecord0_user_firstname' cannot be null.");
    else if (financerecord0_user_firstname !== undefined)
      url_ += "financerecord[0].user.firstname=" + encodeURIComponent("" + financerecord0_user_firstname) + "&";
    if (financerecord0_user_id === null)
      throw new Error("The parameter 'financerecord0_user_id' cannot be null.");
    else if (financerecord0_user_id !== undefined)
      url_ += "financerecord[0].user.id=" + encodeURIComponent("" + financerecord0_user_id) + "&";
    if (financerecord0_user_lastname === null)
      throw new Error("The parameter 'financerecord0_user_lastname' cannot be null.");
    else if (financerecord0_user_lastname !== undefined)
      url_ += "financerecord[0].user.lastname=" + encodeURIComponent("" + financerecord0_user_lastname) + "&";
    if (financerecord0_user_middlename === null)
      throw new Error("The parameter 'financerecord0_user_middlename' cannot be null.");
    else if (financerecord0_user_middlename !== undefined)
      url_ += "financerecord[0].user.middlename=" + encodeURIComponent("" + financerecord0_user_middlename) + "&";
    if (financerecord0_user_password === null)
      throw new Error("The parameter 'financerecord0_user_password' cannot be null.");
    else if (financerecord0_user_password !== undefined)
      url_ += "financerecord[0].user.password=" + encodeURIComponent("" + financerecord0_user_password) + "&";
    if (financerecord0_user_role === null)
      throw new Error("The parameter 'financerecord0_user_role' cannot be null.");
    else if (financerecord0_user_role !== undefined)
      financerecord0_user_role && financerecord0_user_role.forEach(item => { url_ += "financerecord[0].user.role=" + encodeURIComponent("" + item) + "&"; });
    if (financerecord0_user_username === null)
      throw new Error("The parameter 'financerecord0_user_username' cannot be null.");
    else if (financerecord0_user_username !== undefined)
      url_ += "financerecord[0].user.username=" + encodeURIComponent("" + financerecord0_user_username) + "&";
    if (firstname === null)
      throw new Error("The parameter 'firstname' cannot be null.");
    else if (firstname !== undefined)
      url_ += "firstname=" + encodeURIComponent("" + firstname) + "&";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (lastname === null)
      throw new Error("The parameter 'lastname' cannot be null.");
    else if (lastname !== undefined)
      url_ += "lastname=" + encodeURIComponent("" + lastname) + "&";
    if (middlename === null)
      throw new Error("The parameter 'middlename' cannot be null.");
    else if (middlename !== undefined)
      url_ += "middlename=" + encodeURIComponent("" + middlename) + "&";
    if (password === null)
      throw new Error("The parameter 'password' cannot be null.");
    else if (password !== undefined)
      url_ += "password=" + encodeURIComponent("" + password) + "&";
    if (role === null)
      throw new Error("The parameter 'role' cannot be null.");
    else if (role !== undefined)
      role && role.forEach(item => { url_ += "role=" + encodeURIComponent("" + item) + "&"; });
    if (username === null)
      throw new Error("The parameter 'username' cannot be null.");
    else if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindFinanceRecordByIdAndUserFinanceRecordUsingGET(_response);
    });
  }

  protected processFindFinanceRecordByIdAndUserFinanceRecordUsingGET(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }

  /**
   * findByIdFinanceRecord
   * @param id id
   * @return OK
   */
  findByIdFinanceRecordUsingGET(id: number): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindByIdFinanceRecordUsingGET(_response);
    });
  }

  protected processFindByIdFinanceRecordUsingGET(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }

  /**
   * saveFinanceRecord
   * @param id id
   * @param body (optional)
   * @return OK
   */
  saveFinanceRecordUsingPUT(id: number, body: FinanceRecord | undefined): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveFinanceRecordUsingPUT(_response);
    });
  }

  protected processSaveFinanceRecordUsingPUT(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }

  /**
   * deleteFinanceRecord
   * @param id id
   * @return OK
   */
  deleteFinanceRecordUsingDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + "/financeRecords/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteFinanceRecordUsingDELETE(_response);
    });
  }

  protected processDeleteFinanceRecordUsingDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * saveFinanceRecord
   * @param id id
   * @param body (optional)
   * @return OK
   */
  saveFinanceRecordUsingPATCH(id: number, body: FinanceRecord | undefined): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/financeRecords/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveFinanceRecordUsingPATCH(_response);
    });
  }

  protected processSaveFinanceRecordUsingPATCH(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }

  /**
   * userFinancerecord
   * @param id id
   * @return OK
   */
  userFinancerecordUsingGET(id: number): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/users/{id}/financerecord";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "application/hal+json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserFinancerecordUsingGET(_response);
    });
  }

  protected processUserFinancerecordUsingGET(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * userFinancerecord
   * @param id id
   * @param body (optional)
   * @return OK
   */
  userFinancerecordUsingPUT(id: number, body: string[] | undefined): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/users/{id}/financerecord";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserFinancerecordUsingPUT(_response);
    });
  }

  protected processUserFinancerecordUsingPUT(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * userFinancerecord
   * @param id id
   * @param body (optional)
   * @return OK
   */
  userFinancerecordUsingPOST(id: number, body: string[] | undefined): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/users/{id}/financerecord";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserFinancerecordUsingPOST(_response);
    });
  }

  protected processUserFinancerecordUsingPOST(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * userFinancerecord
   * @param id id
   * @param body (optional)
   * @return OK
   */
  userFinancerecordUsingPATCH(id: number, body: string[] | undefined): Promise<CollectionModel_FinanceRecord> {
    let url_ = this.baseUrl + "/users/{id}/financerecord";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserFinancerecordUsingPATCH(_response);
    });
  }

  protected processUserFinancerecordUsingPATCH(response: Response): Promise<CollectionModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_FinanceRecord>(null as any);
  }

  /**
   * userFinancerecord
   * @param id id
   * @param financerecordId financerecordId
   * @return OK
   */
  userFinancerecordUsingDELETE(id: number, financerecordId: string): Promise<void> {
    let url_ = this.baseUrl + "/users/{id}/financerecord/{financerecordId}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (financerecordId === undefined || financerecordId === null)
      throw new Error("The parameter 'financerecordId' must be defined.");
    url_ = url_.replace("{financerecordId}", encodeURIComponent("" + financerecordId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUserFinancerecordUsingDELETE(_response);
    });
  }

  protected processUserFinancerecordUsingDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * findAllUser
   * @param page (optional) page
   * @param size (optional) size
   * @param sort (optional) sort
   * @return OK
   */
  findAllUserUsingGET(page: number | undefined, size: number | undefined, sort: string | undefined): Promise<CollectionModel_User> {
    let url_ = this.baseUrl + "/users?";
    if (page === null)
      throw new Error("The parameter 'page' cannot be null.");
    else if (page !== undefined)
      url_ += "page=" + encodeURIComponent("" + page) + "&";
    if (size === null)
      throw new Error("The parameter 'size' cannot be null.");
    else if (size !== undefined)
      url_ += "size=" + encodeURIComponent("" + size) + "&";
    if (sort === null)
      throw new Error("The parameter 'sort' cannot be null.");
    else if (sort !== undefined)
      url_ += "sort=" + encodeURIComponent("" + sort) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindAllUserUsingGET(_response);
    });
  }

  protected processFindAllUserUsingGET(response: Response): Promise<CollectionModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CollectionModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CollectionModel_User>(null as any);
  }

  /**
   * saveUser
   * @param body (optional)
   * @return OK
   */
  saveUserUsingPOST(body: UserReq | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveUserUsingPOST(_response);
    });
  }

  protected processSaveUserUsingPOST(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * findByUsernameUser
   * @param username (optional) username
   * @return OK
   */
  findByUsernameUserUsingGET(username: string | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/search/findByUsername?";
    if (username === null)
      throw new Error("The parameter 'username' cannot be null.");
    else if (username !== undefined)
      url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindByUsernameUserUsingGET(_response);
    });
  }

  protected processFindByUsernameUserUsingGET(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * findUserByEmailUser
   * @param email (optional) email
   * @return OK
   */
  findUserByEmailUserUsingGET(email: string | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/search/findUserByEmail?";
    if (email === null)
      throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined)
      url_ += "email=" + encodeURIComponent("" + email) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindUserByEmailUserUsingGET(_response);
    });
  }

  protected processFindUserByEmailUserUsingGET(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * findUserByIdUser
   * @param id (optional) id
   * @return OK
   */
  findUserByIdUserUsingGET(id: number | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/search/findUserById?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindUserByIdUserUsingGET(_response);
    });
  }

  protected processFindUserByIdUserUsingGET(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * findByIdUser
   * @param id id
   * @return OK
   */
  findByIdUserUsingGET(id: number): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindByIdUserUsingGET(_response);
    });
  }

  protected processFindByIdUserUsingGET(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * saveUser
   * @param id id
   * @param body (optional)
   * @return OK
   */
  saveUserUsingPUT(id: number, body: UserReq | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveUserUsingPUT(_response);
    });
  }

  protected processSaveUserUsingPUT(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * deleteUser
   * @param id id
   * @return OK
   */
  deleteUserUsingDELETE(id: number): Promise<void> {
    let url_ = this.baseUrl + "/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteUserUsingDELETE(_response);
    });
  }

  protected processDeleteUserUsingDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * saveUser
   * @param id id
   * @param body (optional)
   * @return OK
   */
  saveUserUsingPATCH(id: number, body: UserReq | undefined): Promise<EntityModel_User> {
    let url_ = this.baseUrl + "/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSaveUserUsingPATCH(_response);
    });
  }

  protected processSaveUserUsingPATCH(response: Response): Promise<EntityModel_User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_User.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_User>(null as any);
  }

  /**
   * registerUser
   * @param body (optional)
   * @return OK
   */
  registerUserUsingPOST(body: LoginRequest | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/auth/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegisterUserUsingPOST(_response);
    });
  }

  protected processRegisterUserUsingPOST(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingGET(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingGET(_response);
    });
  }

  protected processErrorHtmlUsingGET(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingPUT(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "PUT",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingPUT(_response);
    });
  }

  protected processErrorHtmlUsingPUT(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingPOST(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingPOST(_response);
    });
  }

  protected processErrorHtmlUsingPOST(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingDELETE(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingDELETE(_response);
    });
  }

  protected processErrorHtmlUsingDELETE(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingOPTIONS(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "OPTIONS",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingOPTIONS(_response);
    });
  }

  protected processErrorHtmlUsingOPTIONS(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingHEAD(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "HEAD",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingHEAD(_response);
    });
  }

  protected processErrorHtmlUsingHEAD(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingPATCH(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "PATCH",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingPATCH(_response);
    });
  }

  protected processErrorHtmlUsingPATCH(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * errorHtml
   * @return OK
   */
  errorHtmlUsingTRACE(): Promise<ModelAndView> {
    let url_ = this.baseUrl + "/error";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "TRACE",
      headers: {
        "Accept": "text/html"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processErrorHtmlUsingTRACE(_response);
    });
  }

  protected processErrorHtmlUsingTRACE(response: Response): Promise<ModelAndView> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ModelAndView.fromJS(resultData200);
        return result200;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ModelAndView>(null as any);
  }

  /**
   * getAllFinanceRecordsByUser
   * @param name (optional)
   * @return OK
   */
  getAllFinanceRecordsByUserUsingGET(name: string | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/FinanceRecord/getAllByUser?";
    if (name === null)
      throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllFinanceRecordsByUserUsingGET(_response);
    });
  }

  protected processGetAllFinanceRecordsByUserUsingGET(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * listAllFormsOfMetadata
   * @return OK
   */
  listAllFormsOfMetadataUsingGET(): Promise<RepresentationModel_object> {
    let url_ = this.baseUrl + "/profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processListAllFormsOfMetadataUsingGET(_response);
    });
  }

  protected processListAllFormsOfMetadataUsingGET(response: Response): Promise<RepresentationModel_object> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RepresentationModel_object.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<RepresentationModel_object>(null as any);
  }

  /**
   * profileOptions
   * @return OK
   */
  profileOptionsUsingOPTIONS(): Promise<FileResponse> {
    let url_ = this.baseUrl + "/profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "OPTIONS",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processProfileOptionsUsingOPTIONS(_response);
    });
  }

  protected processProfileOptionsUsingOPTIONS(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class UserFinancerecordUsingDELETEClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080";
  }

  /**
   * userFinancerecord
   * @param id id
   * @return OK
   */
  1(id: number): Promise<void> {
    let url_ = this.baseUrl + "/users/{id}/financerecord";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.process1(_response);
    });
  }

  protected process1(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class UserFinancerecordUsingGETClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080";
  }

  /**
   * userFinancerecord
   * @param id id
   * @param financerecordId financerecordId
   * @return OK
   */
  1(id: number, financerecordId: string): Promise<EntityModel_FinanceRecord> {
    let url_ = this.baseUrl + "/users/{id}/financerecord/{financerecordId}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (financerecordId === undefined || financerecordId === null)
      throw new Error("The parameter 'financerecordId' must be defined.");
    url_ = url_.replace("{financerecordId}", encodeURIComponent("" + financerecordId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.process1(_response);
    });
  }

  protected process1(response: Response): Promise<EntityModel_FinanceRecord> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EntityModel_FinanceRecord.fromJS(resultData200);
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<EntityModel_FinanceRecord>(null as any);
  }
}

export class RegisterUserUsingPOSTClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080";
  }

  /**
   * registerUser
   * @param body (optional)
   * @return OK
   */
  1(body: SignupRequest | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/auth/signup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.process1(_response);
    });
  }

  protected process1(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * registerUser
   * @param name (optional)
   * @param body (optional)
   * @return OK
   */
  2(name: string | undefined, body: CreateFinanceRecordRequest | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/FinanceRecord/create?";
    if (name === null)
      throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "*/*"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.process2(_response);
    });
  }

  protected process2(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? decodeURIComponent(fileNameMatch[fileNameMatch.length - 1]) : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException("Created", status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException("Unauthorized", status, _responseText, _headers);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        return throwException("Forbidden", status, _responseText, _headers);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("Not Found", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

/** Resources of FinanceRecord */
export class CollectionModel_FinanceRecord implements ICollectionModel_FinanceRecord {
  _embedded!: EmbeddedCollection_FinanceRecord;
  /** Link collection */
  _links!: { [key: string]: Link; };

  constructor(data?: ICollectionModel_FinanceRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this._embedded = new EmbeddedCollection_FinanceRecord();
      this._links = {};
    }
  }

  init(_data?: any) {
    if (_data) {
      this._embedded = _data["_embedded"] ? EmbeddedCollection_FinanceRecord.fromJS(_data["_embedded"]) : new EmbeddedCollection_FinanceRecord();
      if (_data["_links"]) {
        this._links = {} as any;
        for (let key in _data["_links"]) {
          if (_data["_links"].hasOwnProperty(key))
            (<any>this._links)![key] = _data["_links"][key] ? Link.fromJS(_data["_links"][key]) : new Link();
        }
      }
    }
  }

  static fromJS(data: any): CollectionModel_FinanceRecord {
    data = typeof data === 'object' ? data : {};
    let result = new CollectionModel_FinanceRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["_embedded"] = this._embedded ? this._embedded.toJSON() : <any>undefined;
    if (this._links) {
      data["_links"] = {};
      for (let key in this._links) {
        if (this._links.hasOwnProperty(key))
          (<any>data["_links"])[key] = this._links[key] ? this._links[key].toJSON() : <any>undefined;
      }
    }
    return data;
  }
}

/** Resources of FinanceRecord */
export interface ICollectionModel_FinanceRecord {
  _embedded: EmbeddedCollection_FinanceRecord;
  /** Link collection */
  _links: { [key: string]: Link; };
}

/** Resources of User */
export class CollectionModel_User implements ICollectionModel_User {
  _embedded!: EmbeddedCollection_User;
  /** Link collection */
  _links!: { [key: string]: Link; };

  constructor(data?: ICollectionModel_User) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this._embedded = new EmbeddedCollection_User();
      this._links = {};
    }
  }

  init(_data?: any) {
    if (_data) {
      this._embedded = _data["_embedded"] ? EmbeddedCollection_User.fromJS(_data["_embedded"]) : new EmbeddedCollection_User();
      if (_data["_links"]) {
        this._links = {} as any;
        for (let key in _data["_links"]) {
          if (_data["_links"].hasOwnProperty(key))
            (<any>this._links)![key] = _data["_links"][key] ? Link.fromJS(_data["_links"][key]) : new Link();
        }
      }
    }
  }

  static fromJS(data: any): CollectionModel_User {
    data = typeof data === 'object' ? data : {};
    let result = new CollectionModel_User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["_embedded"] = this._embedded ? this._embedded.toJSON() : <any>undefined;
    if (this._links) {
      data["_links"] = {};
      for (let key in this._links) {
        if (this._links.hasOwnProperty(key))
          (<any>data["_links"])[key] = this._links[key] ? this._links[key].toJSON() : <any>undefined;
      }
    }
    return data;
  }
}

/** Resources of User */
export interface ICollectionModel_User {
  _embedded: EmbeddedCollection_User;
  /** Link collection */
  _links: { [key: string]: Link; };
}

export class CreateFinanceRecordRequest implements ICreateFinanceRecordRequest {
  amount?: number;
  type?: number;

  constructor(data?: ICreateFinanceRecordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): CreateFinanceRecordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateFinanceRecordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["amount"] = this.amount;
    data["type"] = this.type;
    return data;
  }
}

export interface ICreateFinanceRecordRequest {
  amount?: number;
  type?: number;
}

/** Embedded collection of FinanceRecord */
export class EmbeddedCollection_FinanceRecord implements IEmbeddedCollection_FinanceRecord {
  /** Resource collection */
  financeRecords!: FinanceRecord[];

  constructor(data?: IEmbeddedCollection_FinanceRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.financeRecords = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["financeRecords"])) {
        this.financeRecords = [] as any;
        for (let item of _data["financeRecords"])
          this.financeRecords!.push(FinanceRecord.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EmbeddedCollection_FinanceRecord {
    data = typeof data === 'object' ? data : {};
    let result = new EmbeddedCollection_FinanceRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.financeRecords)) {
      data["financeRecords"] = [];
      for (let item of this.financeRecords)
        data["financeRecords"].push(item.toJSON());
    }
    return data;
  }
}

/** Embedded collection of FinanceRecord */
export interface IEmbeddedCollection_FinanceRecord {
  /** Resource collection */
  financeRecords: FinanceRecord[];
}

/** Embedded collection of User */
export class EmbeddedCollection_User implements IEmbeddedCollection_User {
  /** Resource collection */
  users!: UserRes[];

  constructor(data?: IEmbeddedCollection_User) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.users = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["users"])) {
        this.users = [] as any;
        for (let item of _data["users"])
          this.users!.push(UserRes.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EmbeddedCollection_User {
    data = typeof data === 'object' ? data : {};
    let result = new EmbeddedCollection_User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users)
        data["users"].push(item.toJSON());
    }
    return data;
  }
}

/** Embedded collection of User */
export interface IEmbeddedCollection_User {
  /** Resource collection */
  users: UserRes[];
}

export class EntityModel_FinanceRecord implements IEntityModel_FinanceRecord {
  amount?: number;
  createdDate?: Date;
  id?: number;
  links?: Links;
  type?: number;

  constructor(data?: IEntityModel_FinanceRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.id = _data["id"];
      this.links = _data["links"] ? Links.fromJS(_data["links"]) : <any>undefined;
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): EntityModel_FinanceRecord {
    data = typeof data === 'object' ? data : {};
    let result = new EntityModel_FinanceRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["amount"] = this.amount;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["id"] = this.id;
    data["links"] = this.links ? this.links.toJSON() : <any>undefined;
    data["type"] = this.type;
    return data;
  }
}

export interface IEntityModel_FinanceRecord {
  amount?: number;
  createdDate?: Date;
  id?: number;
  links?: Links;
  type?: number;
}

export class EntityModel_User implements IEntityModel_User {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthorityRes[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  links?: Links;
  middlename?: string;
  password?: string;
  role?: Role3[];
  username?: string;

  constructor(data?: IEntityModel_User) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountNonExpired = _data["accountNonExpired"];
      this.accountNonLocked = _data["accountNonLocked"];
      if (Array.isArray(_data["authorities"])) {
        this.authorities = [] as any;
        for (let item of _data["authorities"])
          this.authorities!.push(GrantedAuthorityRes.fromJS(item));
      }
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.credentialsNonExpired = _data["credentialsNonExpired"];
      this.email = _data["email"];
      this.enabled = _data["enabled"];
      this.firstname = _data["firstname"];
      this.id = _data["id"];
      this.lastname = _data["lastname"];
      this.links = _data["links"] ? Links.fromJS(_data["links"]) : <any>undefined;
      this.middlename = _data["middlename"];
      this.password = _data["password"];
      if (Array.isArray(_data["role"])) {
        this.role = [] as any;
        for (let item of _data["role"])
          this.role!.push(item);
      }
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): EntityModel_User {
    data = typeof data === 'object' ? data : {};
    let result = new EntityModel_User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accountNonExpired"] = this.accountNonExpired;
    data["accountNonLocked"] = this.accountNonLocked;
    if (Array.isArray(this.authorities)) {
      data["authorities"] = [];
      for (let item of this.authorities)
        data["authorities"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["credentialsNonExpired"] = this.credentialsNonExpired;
    data["email"] = this.email;
    data["enabled"] = this.enabled;
    data["firstname"] = this.firstname;
    data["id"] = this.id;
    data["lastname"] = this.lastname;
    data["links"] = this.links ? this.links.toJSON() : <any>undefined;
    data["middlename"] = this.middlename;
    data["password"] = this.password;
    if (Array.isArray(this.role)) {
      data["role"] = [];
      for (let item of this.role)
        data["role"].push(item);
    }
    data["username"] = this.username;
    return data;
  }
}

export interface IEntityModel_User {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthorityRes[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  links?: Links;
  middlename?: string;
  password?: string;
  role?: Role3[];
  username?: string;
}

export class FinanceRecord implements IFinanceRecord {
  amount?: number;
  createdDate?: Date;
  id?: number;
  type?: number;

  constructor(data?: IFinanceRecord) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.id = _data["id"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): FinanceRecord {
    data = typeof data === 'object' ? data : {};
    let result = new FinanceRecord();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["amount"] = this.amount;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["id"] = this.id;
    data["type"] = this.type;
    return data;
  }
}

export interface IFinanceRecord {
  amount?: number;
  createdDate?: Date;
  id?: number;
  type?: number;
}

export class GrantedAuthority implements IGrantedAuthority {
  authority?: string;

  constructor(data?: IGrantedAuthority) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authority = _data["authority"];
    }
  }

  static fromJS(data: any): GrantedAuthority {
    data = typeof data === 'object' ? data : {};
    let result = new GrantedAuthority();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["authority"] = this.authority;
    return data;
  }
}

export interface IGrantedAuthority {
  authority?: string;
}

export class GrantedAuthorityReq implements IGrantedAuthorityReq {

  constructor(data?: IGrantedAuthorityReq) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): GrantedAuthorityReq {
    data = typeof data === 'object' ? data : {};
    let result = new GrantedAuthorityReq();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IGrantedAuthorityReq {
}

export class GrantedAuthorityRes implements IGrantedAuthorityRes {
  authority?: string;

  constructor(data?: IGrantedAuthorityRes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authority = _data["authority"];
    }
  }

  static fromJS(data: any): GrantedAuthorityRes {
    data = typeof data === 'object' ? data : {};
    let result = new GrantedAuthorityRes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["authority"] = this.authority;
    return data;
  }
}

export interface IGrantedAuthorityRes {
  authority?: string;
}

export class Link implements ILink {
  deprecation?: string;
  href?: string;
  hreflang?: string;
  media?: string;
  name?: string;
  profile?: string;
  rel?: LinkRelation;
  title?: string;
  type?: string;

  constructor(data?: ILink) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deprecation = _data["deprecation"];
      this.href = _data["href"];
      this.hreflang = _data["hreflang"];
      this.media = _data["media"];
      this.name = _data["name"];
      this.profile = _data["profile"];
      this.rel = _data["rel"] ? LinkRelation.fromJS(_data["rel"]) : <any>undefined;
      this.title = _data["title"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): Link {
    data = typeof data === 'object' ? data : {};
    let result = new Link();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["deprecation"] = this.deprecation;
    data["href"] = this.href;
    data["hreflang"] = this.hreflang;
    data["media"] = this.media;
    data["name"] = this.name;
    data["profile"] = this.profile;
    data["rel"] = this.rel ? this.rel.toJSON() : <any>undefined;
    data["title"] = this.title;
    data["type"] = this.type;
    return data;
  }
}

export interface ILink {
  deprecation?: string;
  href?: string;
  hreflang?: string;
  media?: string;
  name?: string;
  profile?: string;
  rel?: LinkRelation;
  title?: string;
  type?: string;
}

export class LinkRelation implements ILinkRelation {

  constructor(data?: ILinkRelation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): LinkRelation {
    data = typeof data === 'object' ? data : {};
    let result = new LinkRelation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface ILinkRelation {
}

export class Links implements ILinks {
  empty?: boolean;

  constructor(data?: ILinks) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.empty = _data["empty"];
    }
  }

  static fromJS(data: any): Links {
    data = typeof data === 'object' ? data : {};
    let result = new Links();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["empty"] = this.empty;
    return data;
  }
}

export interface ILinks {
  empty?: boolean;
}

export class LoginRequest implements ILoginRequest {
  password?: string;
  username?: string;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.password = _data["password"];
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["password"] = this.password;
    data["username"] = this.username;
    return data;
  }
}

export interface ILoginRequest {
  password?: string;
  username?: string;
}

export class ModelAndView implements IModelAndView {
  empty?: boolean;
  model?: any;
  modelMap?: { [key: string]: any; };
  reference?: boolean;
  status?: ModelAndViewStatus;
  view?: View;
  viewName?: string;

  constructor(data?: IModelAndView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.empty = _data["empty"];
      this.model = _data["model"];
      if (_data["modelMap"]) {
        this.modelMap = {} as any;
        for (let key in _data["modelMap"]) {
          if (_data["modelMap"].hasOwnProperty(key))
            (<any>this.modelMap)![key] = _data["modelMap"][key];
        }
      }
      this.reference = _data["reference"];
      this.status = _data["status"];
      this.view = _data["view"] ? View.fromJS(_data["view"]) : <any>undefined;
      this.viewName = _data["viewName"];
    }
  }

  static fromJS(data: any): ModelAndView {
    data = typeof data === 'object' ? data : {};
    let result = new ModelAndView();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["empty"] = this.empty;
    data["model"] = this.model;
    if (this.modelMap) {
      data["modelMap"] = {};
      for (let key in this.modelMap) {
        if (this.modelMap.hasOwnProperty(key))
          (<any>data["modelMap"])[key] = this.modelMap[key];
      }
    }
    data["reference"] = this.reference;
    data["status"] = this.status;
    data["view"] = this.view ? this.view.toJSON() : <any>undefined;
    data["viewName"] = this.viewName;
    return data;
  }
}

export interface IModelAndView {
  empty?: boolean;
  model?: any;
  modelMap?: { [key: string]: any; };
  reference?: boolean;
  status?: ModelAndViewStatus;
  view?: View;
  viewName?: string;
}

export class RepresentationModel_object implements IRepresentationModel_object {
  links?: Links;

  constructor(data?: IRepresentationModel_object) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.links = _data["links"] ? Links.fromJS(_data["links"]) : <any>undefined;
    }
  }

  static fromJS(data: any): RepresentationModel_object {
    data = typeof data === 'object' ? data : {};
    let result = new RepresentationModel_object();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["links"] = this.links ? this.links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IRepresentationModel_object {
  links?: Links;
}

export class SignupRequest implements ISignupRequest {
  confirmPassword?: string;
  email!: string;
  firstname?: string;
  lastname?: string;
  middlename?: string;
  password?: string;

  constructor(data?: ISignupRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.confirmPassword = _data["confirmPassword"];
      this.email = _data["email"];
      this.firstname = _data["firstname"];
      this.lastname = _data["lastname"];
      this.middlename = _data["middlename"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): SignupRequest {
    data = typeof data === 'object' ? data : {};
    let result = new SignupRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["confirmPassword"] = this.confirmPassword;
    data["email"] = this.email;
    data["firstname"] = this.firstname;
    data["lastname"] = this.lastname;
    data["middlename"] = this.middlename;
    data["password"] = this.password;
    return data;
  }
}

export interface ISignupRequest {
  confirmPassword?: string;
  email: string;
  firstname?: string;
  lastname?: string;
  middlename?: string;
  password?: string;
}

export class TemplateVariable implements ITemplateVariable {
  composite?: boolean;
  description?: string;
  name?: string;
  singular?: boolean;
  type?: TemplateVariableType;

  constructor(data?: ITemplateVariable) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.composite = _data["composite"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.singular = _data["singular"];
      this.type = _data["type"];
    }
  }

  static fromJS(data: any): TemplateVariable {
    data = typeof data === 'object' ? data : {};
    let result = new TemplateVariable();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["composite"] = this.composite;
    data["description"] = this.description;
    data["name"] = this.name;
    data["singular"] = this.singular;
    data["type"] = this.type;
    return data;
  }
}

export interface ITemplateVariable {
  composite?: boolean;
  description?: string;
  name?: string;
  singular?: boolean;
  type?: TemplateVariableType;
}

export class UriTemplate implements IUriTemplate {
  variableNames?: string[];
  variables?: TemplateVariable[];

  constructor(data?: IUriTemplate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["variableNames"])) {
        this.variableNames = [] as any;
        for (let item of _data["variableNames"])
          this.variableNames!.push(item);
      }
      if (Array.isArray(_data["variables"])) {
        this.variables = [] as any;
        for (let item of _data["variables"])
          this.variables!.push(TemplateVariable.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UriTemplate {
    data = typeof data === 'object' ? data : {};
    let result = new UriTemplate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.variableNames)) {
      data["variableNames"] = [];
      for (let item of this.variableNames)
        data["variableNames"].push(item);
    }
    if (Array.isArray(this.variables)) {
      data["variables"] = [];
      for (let item of this.variables)
        data["variables"].push(item.toJSON());
    }
    return data;
  }
}

export interface IUriTemplate {
  variableNames?: string[];
  variables?: TemplateVariable[];
}

export class User implements IUser {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthority[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role4[];
  username?: string;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountNonExpired = _data["accountNonExpired"];
      this.accountNonLocked = _data["accountNonLocked"];
      if (Array.isArray(_data["authorities"])) {
        this.authorities = [] as any;
        for (let item of _data["authorities"])
          this.authorities!.push(GrantedAuthority.fromJS(item));
      }
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.credentialsNonExpired = _data["credentialsNonExpired"];
      this.email = _data["email"];
      this.enabled = _data["enabled"];
      this.firstname = _data["firstname"];
      this.id = _data["id"];
      this.lastname = _data["lastname"];
      this.middlename = _data["middlename"];
      this.password = _data["password"];
      if (Array.isArray(_data["role"])) {
        this.role = [] as any;
        for (let item of _data["role"])
          this.role!.push(item);
      }
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accountNonExpired"] = this.accountNonExpired;
    data["accountNonLocked"] = this.accountNonLocked;
    if (Array.isArray(this.authorities)) {
      data["authorities"] = [];
      for (let item of this.authorities)
        data["authorities"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["credentialsNonExpired"] = this.credentialsNonExpired;
    data["email"] = this.email;
    data["enabled"] = this.enabled;
    data["firstname"] = this.firstname;
    data["id"] = this.id;
    data["lastname"] = this.lastname;
    data["middlename"] = this.middlename;
    data["password"] = this.password;
    if (Array.isArray(this.role)) {
      data["role"] = [];
      for (let item of this.role)
        data["role"].push(item);
    }
    data["username"] = this.username;
    return data;
  }
}

export interface IUser {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthority[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role4[];
  username?: string;
}

export class UserReq implements IUserReq {
  authorities?: GrantedAuthorityReq[];
  createdDate?: Date;
  email?: string;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role5[];
  username?: string;

  constructor(data?: IUserReq) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["authorities"])) {
        this.authorities = [] as any;
        for (let item of _data["authorities"])
          this.authorities!.push(GrantedAuthorityReq.fromJS(item));
      }
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.email = _data["email"];
      this.firstname = _data["firstname"];
      this.id = _data["id"];
      this.lastname = _data["lastname"];
      this.middlename = _data["middlename"];
      this.password = _data["password"];
      if (Array.isArray(_data["role"])) {
        this.role = [] as any;
        for (let item of _data["role"])
          this.role!.push(item);
      }
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): UserReq {
    data = typeof data === 'object' ? data : {};
    let result = new UserReq();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.authorities)) {
      data["authorities"] = [];
      for (let item of this.authorities)
        data["authorities"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["email"] = this.email;
    data["firstname"] = this.firstname;
    data["id"] = this.id;
    data["lastname"] = this.lastname;
    data["middlename"] = this.middlename;
    data["password"] = this.password;
    if (Array.isArray(this.role)) {
      data["role"] = [];
      for (let item of this.role)
        data["role"].push(item);
    }
    data["username"] = this.username;
    return data;
  }
}

export interface IUserReq {
  authorities?: GrantedAuthorityReq[];
  createdDate?: Date;
  email?: string;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role5[];
  username?: string;
}

export class UserRes implements IUserRes {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthorityRes[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role6[];
  username?: string;

  constructor(data?: IUserRes) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountNonExpired = _data["accountNonExpired"];
      this.accountNonLocked = _data["accountNonLocked"];
      if (Array.isArray(_data["authorities"])) {
        this.authorities = [] as any;
        for (let item of _data["authorities"])
          this.authorities!.push(GrantedAuthorityRes.fromJS(item));
      }
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.credentialsNonExpired = _data["credentialsNonExpired"];
      this.email = _data["email"];
      this.enabled = _data["enabled"];
      this.firstname = _data["firstname"];
      this.id = _data["id"];
      this.lastname = _data["lastname"];
      this.middlename = _data["middlename"];
      this.password = _data["password"];
      if (Array.isArray(_data["role"])) {
        this.role = [] as any;
        for (let item of _data["role"])
          this.role!.push(item);
      }
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): UserRes {
    data = typeof data === 'object' ? data : {};
    let result = new UserRes();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accountNonExpired"] = this.accountNonExpired;
    data["accountNonLocked"] = this.accountNonLocked;
    if (Array.isArray(this.authorities)) {
      data["authorities"] = [];
      for (let item of this.authorities)
        data["authorities"].push(item.toJSON());
    }
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["credentialsNonExpired"] = this.credentialsNonExpired;
    data["email"] = this.email;
    data["enabled"] = this.enabled;
    data["firstname"] = this.firstname;
    data["id"] = this.id;
    data["lastname"] = this.lastname;
    data["middlename"] = this.middlename;
    data["password"] = this.password;
    if (Array.isArray(this.role)) {
      data["role"] = [];
      for (let item of this.role)
        data["role"].push(item);
    }
    data["username"] = this.username;
    return data;
  }
}

export interface IUserRes {
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  authorities?: GrantedAuthorityRes[];
  createdDate?: Date;
  credentialsNonExpired?: boolean;
  email?: string;
  enabled?: boolean;
  firstname?: string;
  id?: number;
  lastname?: string;
  middlename?: string;
  password?: string;
  role?: Role6[];
  username?: string;
}

export class View implements IView {
  contentType?: string;

  constructor(data?: IView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.contentType = _data["contentType"];
    }
  }

  static fromJS(data: any): View {
    data = typeof data === 'object' ? data : {};
    let result = new View();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["contentType"] = this.contentType;
    return data;
  }
}

export interface IView {
  contentType?: string;
}

export enum FinancerecordOf_0Role {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum Role {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum FinancerecordOf_0Role2 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum Role2 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum Role3 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum ModelAndViewStatus {
  ACCEPTED = "ACCEPTED",
  ALREADY_REPORTED = "ALREADY_REPORTED",
  BAD_GATEWAY = "BAD_GATEWAY",
  BAD_REQUEST = "BAD_REQUEST",
  BANDWIDTH_LIMIT_EXCEEDED = "BANDWIDTH_LIMIT_EXCEEDED",
  CHECKPOINT = "CHECKPOINT",
  CONFLICT = "CONFLICT",
  CONTINUE = "CONTINUE",
  CREATED = "CREATED",
  DESTINATION_LOCKED = "DESTINATION_LOCKED",
  EXPECTATION_FAILED = "EXPECTATION_FAILED",
  FAILED_DEPENDENCY = "FAILED_DEPENDENCY",
  FORBIDDEN = "FORBIDDEN",
  FOUND = "FOUND",
  GATEWAY_TIMEOUT = "GATEWAY_TIMEOUT",
  GONE = "GONE",
  HTTP_VERSION_NOT_SUPPORTED = "HTTP_VERSION_NOT_SUPPORTED",
  IM_USED = "IM_USED",
  INSUFFICIENT_SPACE_ON_RESOURCE = "INSUFFICIENT_SPACE_ON_RESOURCE",
  INSUFFICIENT_STORAGE = "INSUFFICIENT_STORAGE",
  INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
  I_AM_A_TEAPOT = "I_AM_A_TEAPOT",
  LENGTH_REQUIRED = "LENGTH_REQUIRED",
  LOCKED = "LOCKED",
  LOOP_DETECTED = "LOOP_DETECTED",
  METHOD_FAILURE = "METHOD_FAILURE",
  METHOD_NOT_ALLOWED = "METHOD_NOT_ALLOWED",
  MOVED_PERMANENTLY = "MOVED_PERMANENTLY",
  MOVED_TEMPORARILY = "MOVED_TEMPORARILY",
  MULTIPLE_CHOICES = "MULTIPLE_CHOICES",
  MULTI_STATUS = "MULTI_STATUS",
  NETWORK_AUTHENTICATION_REQUIRED = "NETWORK_AUTHENTICATION_REQUIRED",
  NON_AUTHORITATIVE_INFORMATION = "NON_AUTHORITATIVE_INFORMATION",
  NOT_ACCEPTABLE = "NOT_ACCEPTABLE",
  NOT_EXTENDED = "NOT_EXTENDED",
  NOT_FOUND = "NOT_FOUND",
  NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
  NOT_MODIFIED = "NOT_MODIFIED",
  NO_CONTENT = "NO_CONTENT",
  OK = "OK",
  PARTIAL_CONTENT = "PARTIAL_CONTENT",
  PAYLOAD_TOO_LARGE = "PAYLOAD_TOO_LARGE",
  PAYMENT_REQUIRED = "PAYMENT_REQUIRED",
  PERMANENT_REDIRECT = "PERMANENT_REDIRECT",
  PRECONDITION_FAILED = "PRECONDITION_FAILED",
  PRECONDITION_REQUIRED = "PRECONDITION_REQUIRED",
  PROCESSING = "PROCESSING",
  PROXY_AUTHENTICATION_REQUIRED = "PROXY_AUTHENTICATION_REQUIRED",
  REQUESTED_RANGE_NOT_SATISFIABLE = "REQUESTED_RANGE_NOT_SATISFIABLE",
  REQUEST_ENTITY_TOO_LARGE = "REQUEST_ENTITY_TOO_LARGE",
  REQUEST_HEADER_FIELDS_TOO_LARGE = "REQUEST_HEADER_FIELDS_TOO_LARGE",
  REQUEST_TIMEOUT = "REQUEST_TIMEOUT",
  REQUEST_URI_TOO_LONG = "REQUEST_URI_TOO_LONG",
  RESET_CONTENT = "RESET_CONTENT",
  SEE_OTHER = "SEE_OTHER",
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
  SWITCHING_PROTOCOLS = "SWITCHING_PROTOCOLS",
  TEMPORARY_REDIRECT = "TEMPORARY_REDIRECT",
  TOO_EARLY = "TOO_EARLY",
  TOO_MANY_REQUESTS = "TOO_MANY_REQUESTS",
  UNAUTHORIZED = "UNAUTHORIZED",
  UNAVAILABLE_FOR_LEGAL_REASONS = "UNAVAILABLE_FOR_LEGAL_REASONS",
  UNPROCESSABLE_ENTITY = "UNPROCESSABLE_ENTITY",
  UNSUPPORTED_MEDIA_TYPE = "UNSUPPORTED_MEDIA_TYPE",
  UPGRADE_REQUIRED = "UPGRADE_REQUIRED",
  URI_TOO_LONG = "URI_TOO_LONG",
  USE_PROXY = "USE_PROXY",
  VARIANT_ALSO_NEGOTIATES = "VARIANT_ALSO_NEGOTIATES",
}

export enum TemplateVariableType {
  COMPOSITE_PARAM = "COMPOSITE_PARAM",
  DOT = "DOT",
  FRAGMENT = "FRAGMENT",
  PATH_SEGMENT = "PATH_SEGMENT",
  PATH_STYLE_PARAMETER = "PATH_STYLE_PARAMETER",
  PATH_VARIABLE = "PATH_VARIABLE",
  REQUEST_PARAM = "REQUEST_PARAM",
  REQUEST_PARAM_CONTINUED = "REQUEST_PARAM_CONTINUED",
  RESERVED_STRING = "RESERVED_STRING",
  SEGMENT = "SEGMENT",
  SIMPLE = "SIMPLE",
}

export enum Role4 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum Role5 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export enum Role6 {
  ROLE_ADMIN = "ROLE_ADMIN",
  ROLE_USER = "ROLE_USER",
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if (result !== null && result !== undefined)
    throw result;
  else
    throw new ApiException(message, status, response, headers, null);
}
